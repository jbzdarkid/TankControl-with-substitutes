/**
* Selects a player on the infected team from random who hasn't been
* tank and gives it to them.
* Substitutes for players who have already had a tank are not considered.
* Once all original players (or their substitutes) have had a tank, substitutes who have not had a tank will be considered.
* This behaviour allows for 4 players to have a tank, and the substitute to get a tank on map 5.
*/

public chooseTank()
{
    // Create our pool of players to choose from
    new Handle:infectedPool = teamSteamIds(L4D2Team_Infected);

    // Remove players who've already had tank from the pool.
    infectedPool = removeTanksFromPool(infectedPool, h_whosHadTank, true);
    
    LogMessage("[TC-S] Choosing tank from original players...");
    
    // If there are no valid players, select from the actual players playing, i.e. include possible substitutes.
    if (GetArraySize(infectedPool) == 0) {
        LogMessage("[TC-S] No tanks in original pool.");
        LogMessage("[TC-S] Choosing tank from substitutes...");
        infectedPool = teamSteamIds(L4D2Team_Infected);
        infectedPool = removeTanksFromPool(infectedPool, h_whosHadTank, false);
    }

    for (new tank = 0; tank < GetArraySize(infectedPool); tank++) {
        new String:tankId[64];
        GetArrayString(infectedPool, tank, tankId, sizeof(tankId));
        
        new tankClientId = getInfectedPlayerBySteamId(queuedTankSteamId);
        
        new String:name[MAX_NAME_LENGTH];
        GetClientName(tankClientId, name, sizeof(name));
        
        LogMessage("[TC-S] Possible tank: %s", name);
    }

    // If there are still no valid players, put everyone back into the pool.
    if (GetArraySize(infectedPool) == 0) {
        LogMessage("[TC-S] No valid tanks, reseting pool.");
        infectedPool = teamSteamIds(L4D2Team_Infected);
        h_whosHadTank = removeTanksFromPool(h_whosHadTank, infectedPool, false);
        h_whosHadTank = removeTanksFromPool(h_whosHadTank, infectedPool, true);
        // Remove the substitutions, everyone in game has had a tank.
        for (new i = 0; i < 64; i++) {
            new String:steamId[64];
            GetArrayString(infectedPool, i, steamId, sizeof(steamId));
            for (new j = 0; j < 8; j++) {
                if (strcmp(substitutes[j][0], steamId) == 0) {
                    substitutes[j][0] = "";
                    substitutes[j][1] = "";
                }
            }
        }
        if (GetArraySize(infectedPool) == 0) {
            // No valid tanks
            queuedTankSteamId = "";
            return;
        }
    }

    // Select a random person to become tank
    new rndIndex = GetRandomInt(0, GetArraySize(infectedPool) - 1);
    GetArrayString(infectedPool, rndIndex, queuedTankSteamId, sizeof(queuedTankSteamId));
}

/**
 * Removes steam ids from the tank pool if they've already had tank.
 *
 * @param Handle:steamIdTankPool
 *     The pool of potential steam ids to become tank.
 * @param Handle:tanks
 *     The steam ids of players who've already had tank.
 * @param bool:substitute
 *      Remove names of substitues rather than actual players.
 *
 * @return
 *     The pool of steam ids who haven't had tank.
 */
 
public Handle:removeTanksFromPool(Handle:steamIdTankPool, Handle:tanks, bool:substitute)
{
    decl index;
    decl String:steamId[64];
    
    for (new i = 0; i < GetArraySize(tanks); i++)
    {
        GetArrayString(tanks, i, steamId, sizeof(steamId));
        if (substitute) {
            for (new j = 0; j < 8; j++) {
                // Replace the old player name with their substitute. If they've left, remove them anyways.
                if (strcmp(substitutes[j][1], steamId) == 0 && strcmp(substitutes[j][0], "") != 0) {
                    steamId = substitutes[j][0];
                    break;
                }
            }
        }
        index = FindStringInArray(steamIdTankPool, steamId);
        
        if (index != -1)
        {
            RemoveFromArray(steamIdTankPool, index);
        }
    }
    
    return steamIdTankPool;
}